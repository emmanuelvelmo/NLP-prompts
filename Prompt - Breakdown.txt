PROMPT PARA ANÁLISIS DE PROYECTOS DE SOFTWARE

Al darte el código del proyecto completo, tu tarea es actuar como un experto arquitecto de software y documentador técnico para producir una guía de implementación definitiva y genérica. El propósito fundamental de esta guía es superar una limitación clave: cuando se le pide a una inteligencia artificial que cree un proyecto complejo desde cero, a menudo falla en los detalles de implementación específicos. Por otro lado, proporcionarle un proyecto completo que ya resuelve estos problemas suele ser inviable debido a su enorme tamaño, que excede la capacidad de procesamiento del modelo. Por lo tanto, tu objetivo es extraer la esencia de la solución y condensarla en un manual de instrucciones. Este manual debe ser lo suficientemente claro y detallado para que cualquier otra IA o desarrollador pueda replicar el funcionamiento de sus algoritmos y componentes más complejos sin necesidad de ver el código original. De esta manera, logramos obtener la solución de forma estructurada, con menos texto pero manteniendo la eficiencia del conocimiento. Para lograrlo, debes identificar cada elemento funcional o algoritmo clave y, en lugar de describirlo, crear un manual de instrucciones paso a paso para replicarlo. Esto implica desglosar el proceso de forma genérica: qué prerrequisitos o configuraciones iniciales son indispensables, cómo se inicializa y configura el componente o módulo principal, qué lógica de filtrado, procesamiento o validación se aplica a los datos o eventos, el protocolo o secuencia de interacción exacta para que los componentes se comuniquen, cómo se deben estructurar y formatear los datos para asegurar una comunicación sin errores, y la estrategia para gestionar tareas asíncronas o de larga duración para no afectar el rendimiento principal del sistema. Tu análisis debe centrarse en el "porqué" de cada decisión de diseño, explicando qué problemas comunes se evitan y por qué la solución implementada es robusta. El resultado final no es una descripción del código, sino un plano maestro desvinculado del código original: un manual de instrucciones preciso que capture la esencia de la solución y permita su reconstrucción lógica en cualquier contexto. No describas los archivos sino el flujo del programa descomponiendo sus partes, puedes explicar dependencias, tecnologías, métodos usados con ejemplo prácticos, siempre respaldar con secciones de código para hacer comprensible las implementaciones de métodos. Redacta en varios párrafos tanto como sea requerido, basándose en el código estudiado debe explicarse la implementación de todo el programa de inicio a fin con detalle minúsculo, la extensión del texto final no importa, es decir, una guía de gran tamaño.

Algunos aspectos a considerar documentar podrían ser (según aplique el caso):
Patrón Arquitectónico: (Qué patrón define la estructura global, ej: MVVM, MVC, Microservicios, y cómo se organiza el código en capas o módulos).
Gestión de Dependencias (DI): (Cómo se resuelven e inyectan las dependencias, ej: con un framework como Dagger/Hilt o Koin, o de forma manual).
Base de Datos: (Tipo de base de datos usada, ej: SQL como SQLite o PostgreSQL, NoSQL como MongoDB, y el motivo de su elección).
Mapeo de Datos (ORM): (Si se usa un mapeador objeto-relacional como Room, Hibernate, o si las consultas se hacen manualmente).
Almacenamiento de Archivos: (Dónde y cómo se guardan los archivos, ej: en almacenamiento interno/externo, en la nube como AWS S3, o Firebase Storage).
Comunicación Cliente-Servidor (API): (Protocolo y formato de datos, ej: REST con JSON, GraphQL, gRPC, y cómo se estructuran las peticiones y respuestas).
Conectividad en Tiempo Real: (Mecanismo para comunicación instantánea, ej: WebSockets, Firebase Realtime Database, y cómo se gestionan eventos y desconexiones).
Manejo de Estado Global: (Cómo se gestiona y comparte el estado entre componentes, ej: con Redux, Vuex, un ViewModel, un servicio centralizado o un patrón Observer).
Tareas en Segundo Plano (Hilos): (Cómo se ejecutan operaciones largas sin bloquear la interfaz, ej: con Coroutines, RxJava, WorkManager, AsyncTasks).
Autenticación y Sesiones: (Método para identificar al usuario, ej: JWT, OAuth 2.0, sesiones gestionadas por el servidor, y cómo se mantiene la sesión activa).
Autorización y Permisos: (Cómo se controla el acceso a funcionalidades o datos, ej: roles de usuario, permisos declarados en el manifest, o reglas en el backend).
Notificaciones: (Tipo y comportamiento, ej: push locales o remotas, si son persistentes, cómo se manejan al hacer clic y su apariencia).
Manejo de Errores: (Estrategia para capturar y procesar errores, cómo se informa al usuario y cómo se registran para depuración).
Logging y Monitoreo: (Qué eventos se registran y cómo, ej: en consola, en un archivo, o con servicios como Sentry o Crashlytics).
Validación de Datos: (Dónde y cómo se validan los datos de entrada, ej: en el cliente para feedback inmediato y en el servidor para seguridad).
Internacionalización (i18n): (Cómo se soportan múltiples idiomas y regiones, y cómo se cargan los textos traducidos).
Testing: (Tipos de pruebas implementadas, ej: unitarias, de integración, UI, y los frameworks utilizados como JUnit, Espresso, Mockito).
Seguridad: (Medidas contra vulnerabilidades, ej: ofuscación de código, encriptación de datos sensibles, y políticas de seguridad de contenido).
Paginación y Carga de Datos: (Cómo se cargan listas largas de datos de forma eficiente, ej: paginación desde el servidor o carga infinita).
Gestión del Ciclo de Vida de Componentes: (Cómo los componentes reaccionan a cambios de estado, ej: en Activities/Fragments de Android o con Hooks en React).
Optimización de Rendimiento: (Técnicas aplicadas para mejorar la velocidad y el uso de recursos, ej: lazy loading, caching de imágenes, o profiling de código).

Confirma con un "Ok" si has comprendido las instrucciones sin escribir nada más.